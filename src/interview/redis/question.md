## 什么是 Redis ？
Redis 是一个非关系型（**NoSQL**）的内存数据库，使用一对 **Key** 和 **Value** 来存储我们的数据。  
它主要的数据结构有字符串（Strings）、哈希（Hashes）、列表（Lists）、集合（Sets）、有序集合（Sorted Sets 或者说 ZSets）。
## Redis 为什么这么快？
1. C 语言编写。
2. 基于内存实现，访问内存比访问磁盘更快。
3. I/O 复用模型，基于epoll/select/kqueue等I/O多路复用技术实现高吞吐量网络I/O。
4. 单线程模型，避免了多线程的频繁上下文切换以及锁等同步机制的开销。
5. 使用 Key Value 的方式存储，查询速度快。
![why-redis-so-fast](/.image/interview/why-redis-so-fast.jpg)
## Redis 可以用来做什么？
1. 短信验证码
2. 缓存: 存储热点数据（查询多，增删改少），提升系统并发
3. 分布式锁
4. 计数器
5. Token 存储
6. 排行版
7. 消息队列
8. 限流
9. ......
## Redisson 的分布式锁是可重入的吗？
**可重入**: 即可重复获取，假设**线程T**获取到**锁A**之后，**线程T**再次获取**锁A**还是可以获取到的。Redisson 是可重入锁。Java 中的 Synchronized、ReentrantLock 都是可重入锁。
## 实现分布式锁需要注意哪些问题（坑）？
1. 没有保证原子性
::: details
获取锁：setnx key value  
设置锁过期时间：expire key 30  
执行业务代码  
释法锁：del key  
:::
2. 没有释放锁
3. 释放了锁，但业务还没执行完
4. 释放了别人的锁
5. 大量请求竞争锁失败
6. 多节点 Redis 主从复制的问题
::: info
主从复制期间的会数据不一致
:::
7. 锁的性能问题
::: info
使用间隙锁
:::
8. 锁的可重入性
## 采用 Redis 缓存，遇到缓存穿透、缓存击穿、缓存雪崩怎么办？
- 缓存穿透：缓存穿透是由于请求一个不存在的数据而导致的
    - 缓存空结果，对数据库查询不存在的数据也存到缓存中，有效减少查询数据库的次数  
    优点：实现比较简单  
    缺点：缓存了无效数据，占内存，可能存在缓存和数据库不一致的情况
    - 布隆过滤器  
    优点：不会缓存无效数据  
    缺点：实现比较复杂，存在一定的误判
- 缓存击穿：高并发下，热点数据失效的一瞬间，或者刚开始时缓存中还没有对热点数据进行缓存，所有请求都跑到数据库了，数据库被压垮
    - 设置全局锁：拿到锁的才有资格去访问数据库，其他线程必须等待
    - 热点数据，设置永不过期  
    第一种：Redis 不设置过期时间，也就是“物理”不过期  
    优点：简单  
    缺点：缓存的热点数据是静态，得不到更新  
    第二种：Redis 不设置过期时间，但在 Value 中增加一个过期时间的属性，如果查询的时候发现过期了，通过一个后台的一步线程进行缓存重建，即“逻辑”过期
- 缓存雪崩：在某一个时刻，大量的 Key 或者整个缓存的数据全部过期了，然后所有的请求都跑到数据库去了，导致数据库被压垮。或者缓存发生了故障，导致所有的请求都跑到数据库里，数据库被压垮
    - Redis 要高可用（搭建 Redis Sentinel 或者 Redis Cluster 集群），避免 Redis 不可用  
    给不同的 Key 设置不同的过期时间，可以增加一个随机数  
    本地缓存（二级缓存）+ 限流 & 降级，避免数据库被压垮